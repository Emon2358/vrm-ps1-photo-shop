<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GHOST_PROTOCOL_V7_PSYCHO_GLITCH_FIXED</title>
    <link rel="icon" href="data:,">

    <style>
        /* --- VOID STYLING --- */
        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%;
            background-color: #000; overflow: hidden;
            font-family: 'Courier New', Courier, monospace;
        }

        #canvas {
            display: block; position: absolute; top: 0; left: 0; z-index: 1;
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10; pointer-events: none;
            padding: 20px; box-sizing: border-box;
            color: #fff;
            mix-blend-mode: difference; 
        }

        h1 { 
            font-size: 2rem; margin: 0; letter-spacing: 8px; font-weight: 900;
            border-bottom: 4px solid #fff; display: inline-block;
            animation: textRuin 0.05s infinite alternate; 
        }
        @keyframes textRuin {
            0% { transform: translate(0,0); filter: hue-rotate(0deg); }
            33% { transform: translate(3px, -3px); filter: hue-rotate(120deg); }
            66% { transform: translate(-3px, 3px); filter: hue-rotate(240deg); }
            100% { transform: translate(0,0); filter: hue-rotate(360deg); }
        }

        p { font-size: 0.9rem; font-weight: bold; background: #fff; color: #000; display: inline-block; padding: 2px; }

        .controls {
            margin-top: 40px; pointer-events: auto; display: flex; gap: 15px; flex-wrap: wrap;
        }

        .cyber-btn {
            padding: 15px 30px; border: 3px solid #fff; background: #000;
            color: #fff; cursor: pointer; font-weight: 900; font-family: inherit;
            text-transform: uppercase; font-size: 1rem;
            transition: 0.05s;
        }
        .cyber-btn:hover { background: #fff; color: #000; transform: scale(1.1); }
        .cyber-btn.active { background: #f00; color: #fff; border-color: #f00; }
        .cyber-btn:disabled { opacity: 0.2; cursor: not-allowed; }

        #status-log {
            position: absolute; bottom: 20px; left: 20px; 
            font-size: 0.8rem; font-weight: bold; white-space: pre;
        }

        #rec-indicator {
            display: none; position: absolute; top: 20px; right: 20px;
            color: #f00; font-size: 2rem; font-weight: 900;
            animation: blinkExtreme 0.02s infinite; border: 5px solid #f00; padding: 10px;
        }
        @keyframes blinkExtreme { 0%, 100% { opacity: 1; } 50% { opacity: 0; } }

        input[type="file"] { display: none; }
    </style>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
            "@pixiv/three-vrm": "https://unpkg.com/@pixiv/three-vrm@2.1.0/lib/three-vrm.module.js"
        }
    }
    </script>
</head>
<body>
    <div id="ui-layer">
        <h1>V7: PSYCHO_GLITCH</h1>
        <br><br>
        <p>!!! WARNING: COGNITIVE HAZARD !!!</p>
        <br>
        <p>>> SENSITIVITY: OVERLOAD</p>

        <div class="controls">
            <input type="file" id="vrm-input" accept=".vrm">
            <label for="vrm-input" class="cyber-btn">LOAD VRM</label>
            
            <input type="file" id="audio-input" accept=".mp3, .wav, .flac, .m4a">
            <label for="audio-input" class="cyber-btn">LOAD AUDIO</label>

            <button id="btn-play" class="cyber-btn" disabled>INITIATE</button>
            <button id="btn-rec" class="cyber-btn">REC</button>
        </div>

        <div id="rec-indicator">RECORDING</div>
        <div id="status-log">SYSTEM ONLINE. AWAITING SIGNAL...</div>
    </div>

    <canvas id="canvas"></canvas>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
        import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
        import { VRMLoaderPlugin, VRMUtils } from '@pixiv/three-vrm';

        const logDiv = document.getElementById('status-log');
        const log = (msg) => { logDiv.innerText = `>> ${msg}`; console.log(msg); };

        // --- 1. SCENE ---
        const canvas = document.getElementById('canvas');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000); 

        const camera = new THREE.PerspectiveCamera(30, window.innerWidth / window.innerHeight, 0.1, 100.0);
        camera.position.set(0, 1.3, 3.0); 
        camera.lookAt(0, 1.0, 0); 
        
        const renderer = new THREE.WebGLRenderer({ canvas: canvas, preserveDrawingBuffer: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        // Lighting
        const spotLight = new THREE.SpotLight(0xffffff, 5.0, 10, Math.PI / 4, 0.5, 2.0);
        spotLight.position.set(0, 5, 0);
        spotLight.target.position.set(0, 1, 0);
        scene.add(spotLight);
        scene.add(spotLight.target);

        // --- 2. PSYCHO GLITCH SHADER ---
        const V7PsychoGlitchShader = {
            uniforms: {
                "tDiffuse": { value: null },
                "time": { value: 0.0 },
                "audioPower": { value: 0.0 }, 
                "resolution": { value: new THREE.Vector2() }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
                }
            `,
            fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform float time;
                uniform float audioPower; 
                varying vec2 vUv;

                float random(vec2 st) {
                    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
                }

                float noise(vec2 st) {
                    return fract(sin(dot(st, vec2(12.9898, 78.233))) * 43758.5453);
                }

                void main() {
                    vec2 p = vUv;
                    
                    float power = pow(audioPower, 3.0) * 10.0; 
                    float chaos = random(vec2(time, 0.0)); 

                    // 1. PIXEL DISTORTION & SHIFT
                    float grid_scale = 10.0 + power * 50.0; 
                    vec2 grid_coord = floor(p * grid_scale);
                    
                    float shift_x = (random(vec2(grid_coord.x, time * 10.0)) - 0.5) * power * 0.2;
                    float shift_y = (random(vec2(grid_coord.y, time * 10.0)) - 0.5) * power * 0.1;
                    
                    p.x += shift_x;
                    p.y += shift_y;

                    // 2. HUE SHIFT (FIXED)
                    float hue_shift_amount = power * 0.5;
                    vec3 finalColor = texture2D(tDiffuse, p).rgb;

                    float Cmax = max(max(finalColor.r, finalColor.g), finalColor.b);
                    float Cmin = min(min(finalColor.r, finalColor.g), finalColor.b);
                    float delta = Cmax - Cmin;
                    
                    float h = 0.0;
                    if (delta > 0.0) {
                        if (Cmax == finalColor.r) h = mod((finalColor.g - finalColor.b) / delta, 6.0);
                        else if (Cmax == finalColor.g) h = (finalColor.b - finalColor.r) / delta + 2.0;
                        else h = (finalColor.r - finalColor.g) / delta + 4.0;
                    }
                    h = h / 6.0;

                    h = mod(h + hue_shift_amount + time * 0.1, 1.0); 

                    float r = abs(h * 6.0 - 3.0) - 1.0;
                    float g = 2.0 - abs(h * 6.0 - 2.0);
                    float b = 2.0 - abs(h * 6.0 - 4.0);
                    vec3 h_rotated_rgb = clamp(vec3(r, g, b), 0.0, 1.0);
                    
                    // --- 修正箇所: mixの引数をすべてvec3に合わせました ---
                    finalColor = mix(vec3(Cmin), vec3(Cmax), h_rotated_rgb);
                    // ------------------------------------------------

                    // 3. INVERT & FLASH
                    if (power > 0.5 && chaos > 0.3) { 
                        finalColor = 1.0 - finalColor;
                    }
                    if (power > 0.8 && chaos > 0.7) { 
                        finalColor += vec3(1.0) * (power * 0.5); 
                    }

                    // 4. DISTORTION NOISE
                    float distort_noise_amount = noise(p * 100.0 + time * 20.0) * power * 0.5;
                    finalColor += distort_noise_amount;

                    // 5. GRID DISRUPTION
                    float grid_strength = power * 0.2;
                    vec2 line_coord = fract(p * 50.0 + time * 5.0);
                    if (line_coord.x < grid_strength || line_coord.y < grid_strength) {
                        finalColor.rgb = mix(finalColor.rgb, vec3(1.0, 0.0, 1.0), grid_strength); 
                    }

                    finalColor = (finalColor - 0.5) * (1.5 + power) + 0.5;

                    gl_FragColor = vec4(finalColor, 1.0);
                }
            `
        };

        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        
        const psychoGlitchPass = new ShaderPass(V7PsychoGlitchShader);
        composer.addPass(psychoGlitchPass);
        
        const outputPass = new OutputPass();
        composer.addPass(outputPass);


        // --- 3. AUDIO SYSTEM ---
        let audioCtx, analyser, dataArray, source;
        let audioEl = new Audio();
        audioEl.loop = true; 
        audioEl.crossOrigin = "anonymous";

        const playBtn = document.getElementById('btn-play');

        function setupAudioContext() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioCtx.createAnalyser();
                analyser.fftSize = 2048; 
                analyser.smoothingTimeConstant = 0.0; 
                dataArray = new Uint8Array(analyser.frequencyBinCount);

                source = audioCtx.createMediaElementSource(audioEl);
                source.connect(analyser);
                analyser.connect(audioCtx.destination); 
            }
        }

        document.getElementById('audio-input').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const url = URL.createObjectURL(file);
            audioEl.src = url;
            log("AUDIO DATA LOADED.");
            playBtn.disabled = false;
        });

        playBtn.addEventListener('click', () => {
            setupAudioContext();
            if (audioCtx.state === 'suspended') audioCtx.resume();

            if (audioEl.paused) {
                audioEl.play();
                playBtn.innerText = "HALT";
                playBtn.classList.add('active');
                log("SIGNAL INITIATED.");
            } else {
                audioEl.pause();
                playBtn.innerText = "INITIATE";
                playBtn.classList.remove('active');
                log("SIGNAL HALTED.");
            }
        });


        // --- 4. VRM SETUP ---
        const loader = new GLTFLoader();
        loader.register((parser) => new VRMLoaderPlugin(parser));
        let currentVrm = null;

        function loadVRM(url) {
            loader.load(url, (gltf) => {
                if(currentVrm) {
                    scene.remove(currentVrm.scene);
                    VRMUtils.deepDispose(currentVrm.scene);
                }
                const vrm = gltf.userData.vrm;
                VRMUtils.rotateVRM0(vrm);
                currentVrm = vrm;
                scene.add(vrm.scene);
                
                // 固定
                currentVrm.scene.position.set(0, -0.5, 0); 
                currentVrm.scene.rotation.set(0, 0, 0); 
                currentVrm.humanoid.getNormalizedBoneNode('spine').rotation.x = 0.1; 

                log("TARGET ACQUIRED: VRM OK");
            });
        }
        
        loadVRM('https://raw.githubusercontent.com/pixiv/three-vrm/master/packages/three-vrm/examples/models/VRM1_Constraint_Twist_Sample.vrm');

        document.getElementById('vrm-input').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) loadVRM(URL.createObjectURL(new Blob([file], { type: "application/octet-stream" })));
        });


        // --- 5. RECORDER ---
        let mediaRecorder;
        let recordedChunks = [];
        const recBtn = document.getElementById('btn-rec');
        const recIndicator = document.getElementById('rec-indicator');

        recBtn.addEventListener('click', () => {
            if (mediaRecorder && mediaRecorder.state === 'recording') stopRecording();
            else startRecording();
        });

        function startRecording() {
            const canvasStream = canvas.captureStream(60); 
            if (audioCtx && !audioEl.paused) {
                const dest = audioCtx.createMediaStreamDestination();
                source.connect(dest); 
                canvasStream.addTrack(dest.stream.getAudioTracks()[0]);
            }
            let options = { mimeType: 'video/webm;codecs=vp9', videoBitsPerSecond: 12000000 }; 
            if (!MediaRecorder.isTypeSupported(options.mimeType)) options = { mimeType: 'video/webm' };

            mediaRecorder = new MediaRecorder(canvasStream, options);
            mediaRecorder.ondataavailable = (e) => { if (e.data.size > 0) recordedChunks.push(e.data); };
            mediaRecorder.onstop = () => {
                const blob = new Blob(recordedChunks, { type: 'video/webm' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                a.download = 'PSYCHO_LOG_' + Date.now() + '.webm';
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
                recordedChunks = [];
                log("RECORD COMPLETE.");
            };
            mediaRecorder.start();
            recBtn.classList.add('active');
            recIndicator.style.display = 'block';
            log("RECORDING IN PROGRESS...");
        }

        function stopRecording() {
            mediaRecorder.stop();
            recBtn.classList.remove('active');
            recIndicator.style.display = 'none';
        }

        // --- 6. RENDER LOOP ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const deltaTime = clock.getDelta();
            const time = clock.getElapsedTime();

            let power = 0;

            if (analyser && !audioEl.paused) {
                analyser.getByteFrequencyData(dataArray);
                
                let sum = 0;
                for(let i=0; i < dataArray.length; i++) {
                    sum += dataArray[i];
                }
                let avg = sum / dataArray.length / 255.0;
                
                power = avg * 2.0; 
            }

            if (currentVrm) {
                currentVrm.update(deltaTime);
                currentVrm.scene.position.set(0, -0.5, 0);
                currentVrm.scene.rotation.set(0, 0, 0);
            }

            psychoGlitchPass.uniforms['time'].value = time;
            psychoGlitchPass.uniforms['audioPower'].value = power; 

            composer.render();
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GHOST_PROTOCOL_VJ_V4_DESTRUCTION</title>
    <link rel="icon" href="data:,">

    <style>
        /* --- UNDERGROUND STYLING --- */
        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%;
            background-color: #000000; overflow: hidden;
            font-family: 'Press Start 2P', 'Courier New', Courier, monospace; /* レトロゲームフォントを想定 */
        }

        /* 背景の砂嵐ノイズ (アバターが消えた時に見える) */
        .static-noise {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            opacity: 0.3; z-index: 0; pointer-events: none;
            background: url('https://media.giphy.com/media/oEI9uBYSzLpBK/giphy.gif');
            background-size: cover;
            filter: grayscale(100%) contrast(300%) brightness(70%);
        }

        #canvas {
            display: block; position: absolute; top: 0; left: 0; z-index: 1;
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10; pointer-events: none;
            padding: 20px; box-sizing: border-box;
            color: #00ff00; /* ターミナルグリーン */
            text-shadow: 0 0 5px #00ff00, 0 0 10px #00ff00;
            background: linear-gradient(to bottom, rgba(0,0,0,0.9) 0%, rgba(0,0,0,0) 25%);
            filter: saturate(150%);
        }

        h1 { 
            font-size: 1.6rem; margin: 0; letter-spacing: 5px; 
            border-bottom: 2px solid #00ff00; display: inline-block; background: rgba(0,0,0,0.8);
            animation: textGlitch 0.5s infinite alternate;
        }
        @keyframes textGlitch {
            0% { transform: translate(0,0); filter: hue-rotate(0deg); }
            33% { transform: translate(1px, -1px); filter: hue-rotate(90deg); }
            66% { transform: translate(-1px, 1px); filter: hue-rotate(180deg); }
            100% { transform: translate(0,0); filter: hue-rotate(270deg); }
        }

        p { 
            font-size: 0.8rem; margin: 5px 0; background: rgba(0,0,0,0.8); display: inline-block; 
            color: #00ffff; /* シアン */
            text-shadow: 0 0 3px #00ffff;
        }

        /* Controls */
        .controls {
            margin-top: 20px; pointer-events: auto; display: flex; gap: 10px; flex-wrap: wrap;
        }

        .cyber-btn {
            padding: 10px 20px; border: 2px solid #00ff00; background: #000;
            color: #00ff00; cursor: pointer; font-weight: bold; font-family: inherit;
            transition: 0.1s; text-transform: uppercase;
            min-width: 120px; text-align: center;
            box-shadow: 0 0 5px rgba(0,255,0,0.5);
        }
        .cyber-btn:hover { background: #00ff00; color: #000; box-shadow: 0 0 15px #00ff00;}
        .cyber-btn.active { background: #00ff00; color: #fff; box-shadow: 0 0 20px #00ff00; }
        .cyber-btn:disabled { opacity: 0.2; cursor: not-allowed; border-color: #555; color: #555; box-shadow: none;}

        /* 録画ボタン */
        #btn-rec { border-color: #ff00ff; color: #ff00ff; box-shadow: 0 0 5px rgba(255,0,255,0.5);}
        #btn-rec:hover { background: #ff00ff; color: #000; box-shadow: 0 0 15px #ff00ff; }
        #btn-rec.active { background: #ff00ff; color: #fff; box-shadow: 0 0 20px #ff00ff; }

        #status-log {
            position: absolute; bottom: 20px; left: 20px; 
            font-size: 0.7rem; color: #fff; white-space: pre;
            background: rgba(0,0,0,0.9); padding: 5px;
            border: 1px dashed #00ffff;
            box-shadow: 0 0 5px #00ffff;
        }

        /* 録画中インジケーター */
        #rec-indicator {
            display: none; position: absolute; top: 20px; right: 20px;
            color: #ff00ff; font-weight: bold; animation: blinkFast 0.1s infinite;
            background: rgba(0,0,0,0.8); padding: 5px; border: 2px solid #ff00ff;
            font-size: 1.4rem;
            box-shadow: 0 0 10px #ff00ff;
        }
        @keyframes blinkFast { 0% { opacity: 1; } 49% { opacity: 1; } 50% { opacity: 0; } 100% { opacity: 0; } }

        input[type="file"] { display: none; }
    </style>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
            "@pixiv/three-vrm": "https://unpkg.com/@pixiv/three-vrm@2.1.0/lib/three-vrm.module.js"
        }
    }
    </script>
</head>
<body>
    <div class="static-noise"></div>

    <div id="ui-layer">
        <h1>V4.0: DESTRUCTION_PROTOCOL</h1>
        <div>
            <p>>> VISUAL INTEGRITY: CRITICAL</p><br>
            <p>>> AUDIO RESPONSE: HYPER_SENSITIVE</p>
        </div>

        <div class="controls">
            <input type="file" id="vrm-input" accept=".vrm">
            <label for="vrm-input" class="cyber-btn">1. LOAD VRM</label>
            
            <input type="file" id="audio-input" accept=".mp3, .wav, .flac, .m4a">
            <label for="audio-input" class="cyber-btn">2. LOAD AUDIO</label>

            <button id="btn-play" class="cyber-btn" disabled>PLAY / PAUSE</button>
            
            <button id="btn-rec" class="cyber-btn">REC START</button>
        </div>

        <div id="rec-indicator">!! REC !!</div>
        <div id="status-log">SYSTEM BOOTING...</div>
    </div>

    <canvas id="canvas"></canvas>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
        import { OutputPass } from 'three/addons/postprocessing/OutputPass.js'; // OutputPassをインポート
        import { VRMLoaderPlugin, VRMUtils } from '@pixiv/three-vrm';

        // --- UTILS: Logger ---
        const logDiv = document.getElementById('status-log');
        const log = (msg) => { 
            logDiv.innerText = `>> ${msg}\n` + logDiv.innerText.substring(0, Math.min(logDiv.innerText.length, 100)); 
            console.log(msg); 
        };

        // --- 1. SCENE SETUP ---
        const canvas = document.getElementById('canvas');
        const scene = new THREE.Scene();
        scene.background = null; 

        const camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 100.0);
        camera.position.set(0, 1.4, 3.0); // アバターを少し見下ろす位置に
        camera.lookAt(0, 1.0, 0); // 中央のアバターを見る

        const renderer = new THREE.WebGLRenderer({ canvas: canvas, alpha: true, preserveDrawingBuffer: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        // Light - より厳しく、サイバーパンクな照明に
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.5); // 全体的な明るさ
        dirLight.position.set(0.5, 2, 1).normalize();
        scene.add(dirLight);
        
        const cyberRedLight = new THREE.PointLight(0xff0055, 10.0, 10); // 赤いアクセントライト
        cyberRedLight.position.set(-2, 1.5, 0);
        scene.add(cyberRedLight);

        const cyberBlueLight = new THREE.PointLight(0x00ffff, 10.0, 10); // 青いアクセントライト
        cyberBlueLight.position.set(2, 1.5, 0);
        scene.add(cyberBlueLight);

        // --- 2. DESTRUCTION SHADER ---
        const V4DestructionShader = {
            uniforms: {
                "tDiffuse": { value: null },
                "time": { value: 0.0 },
                "audioLow": { value: 0.0 }, 
                "audioMid": { value: 0.0 }, 
                "audioHigh": { value: 0.0 },
                "resolution": { value: new THREE.Vector2() }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
                }
            `,
            fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform float time;
                uniform float audioLow;
                uniform float audioMid;
                uniform float audioHigh;
                uniform vec2 resolution;
                varying vec2 vUv;

                float random(vec2 st) {
                    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
                }

                vec2 hash( vec2 p ) {
                    p = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );
                    return -1.0 + 2.0 * fract(sin(p)*43758.5453123);
                }

                float noise( vec2 p ) {
                    const float K = 0.5/sqrt(2.0);
                    vec2 i = floor( p );
                    vec2 f = p - i;
                    vec2 u = f*f*(3.0-2.0*f);
                    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), 
                                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),
                                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), 
                                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);
                }

                void main() {
                    vec2 p = vUv;
                    vec2 coord = vUv * resolution;

                    vec4 finalColor = texture2D(tDiffuse, p);
                    
                    // 1. DATA MOSH GRID (Low) - グリッド状の分裂と破壊
                    float grid_intensity = audioLow * 0.2;
                    float grid_size = 50.0 + (audioLow * 200.0);
                    vec2 grid_p = floor(p * grid_size) / grid_size;
                    
                    float grid_offset = random(grid_p * time * 5.0) * grid_intensity;
                    p.x += sin(grid_p.y * 10.0 + time * 10.0) * grid_offset;
                    p.y += cos(grid_p.x * 10.0 + time * 10.0) * grid_offset;

                    // 2. SCANLINES & BLUR (Mid) - レトロCRT風
                    float scanline = sin(p.y * resolution.y * 2.0) * 0.05 + 0.95;
                    finalColor.rgb *= scanline;

                    float blur_amount = audioMid * 0.005;
                    finalColor = texture2D(tDiffuse, p + vec2(blur_amount, blur_amount)) * 0.25 +
                                 texture2D(tDiffuse, p + vec2(-blur_amount, blur_amount)) * 0.25 +
                                 texture2D(tDiffuse, p + vec2(blur_amount, -blur_amount)) * 0.25 +
                                 texture2D(tDiffuse, p + vec2(-blur_amount, -blur_amount)) * 0.25;

                    // 3. COLOR CHANNEL SHIFT & SORT (High) - RGBチャネルの激しいズレとピクセルソート
                    float shift_strength = audioHigh * 0.05;
                    float sort_strength = audioHigh * 0.1;
                    
                    vec4 shiftedColor;
                    shiftedColor.r = texture2D(tDiffuse, p + vec2(shift_strength, 0.0)).r;
                    shiftedColor.g = texture2D(tDiffuse, p + vec2(-shift_strength * 0.5, shift_strength * 0.5)).g;
                    shiftedColor.b = texture2D(tDiffuse, p + vec2(0.0, -shift_strength)).b;
                    shiftedColor.a = texture2D(tDiffuse, p).a;

                    // Pixel Sorting-like effect
                    float sort_noise = random(floor(coord / 10.0) + time);
                    if (sort_noise > 1.0 - sort_strength) {
                        float sort_offset = (random(floor(p.y * 100.0) + time) - 0.5) * sort_strength * 2.0;
                        shiftedColor = texture2D(tDiffuse, p + vec2(sort_offset, 0.0));
                    }
                    finalColor = mix(finalColor, shiftedColor, 0.7); // 元の色と混ぜる


                    // 4. HEAVY DIGITAL NOISE & DOT PATTERN (Overall Loudness)
                    float total_loudness = (audioLow + audioMid + audioHigh) / 3.0;
                    float noise_amount = random(p * time + total_loudness * 10.0) * 0.3 * total_loudness;
                    finalColor.rgb += noise_amount;

                    float dot_pattern_size = 50.0 + (1.0 - total_loudness) * 200.0;
                    if (mod(floor(p.x * dot_pattern_size) + floor(p.y * dot_pattern_size), 2.0) < 1.0) {
                        finalColor.rgb *= (1.0 - total_loudness * 0.2); // 音が大きいとドットが濃くなる
                    }

                    // 5. EDGE HIGHLIGHT (Always, but more intense with audio)
                    float edge_strength = 0.005 + total_loudness * 0.01;
                    vec4 edge_color = texture2D(tDiffuse, p);
                    vec4 dx = texture2D(tDiffuse, p + vec2(edge_strength, 0.0));
                    vec4 dy = texture2D(tDiffuse, p + vec2(0.0, edge_strength));
                    float edge = length(dx.rgb - edge_color.rgb) + length(dy.rgb - edge_color.rgb);
                    finalColor.rgb += edge * (1.0 + total_loudness * 2.0); // エッジを強調

                    // 6. Color Invert (Low-Mid Pulse)
                    if (audioLow > 0.6 && audioMid > 0.5 && random(vec2(time, 0.0)) > 0.85) {
                        finalColor.rgb = 1.0 - finalColor.rgb;
                    }

                    gl_FragColor = finalColor;
                }
            `
        };

        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        
        const destructionPass = new ShaderPass(V4DestructionShader);
        destructionPass.uniforms['resolution'].value.set(window.innerWidth, window.innerHeight);
        composer.addPass(destructionPass);

        // 必ず最後にOutputPassを追加して、カラー変換を適用する
        const outputPass = new OutputPass();
        composer.addPass(outputPass);


        // --- 3. AUDIO FILE SYSTEM (ENHANCED) ---
        let audioCtx, analyser, dataArray, source;
        let audioEl = new Audio();
        audioEl.loop = true; 
        audioEl.crossOrigin = "anonymous";

        const playBtn = document.getElementById('btn-play');

        function setupAudioContext() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioCtx.createAnalyser();
                analyser.fftSize = 1024; // さらに解像度を上げて細かく取る
                analyser.smoothingTimeConstant = 0.5; // 反応を極限まで鋭くする
                dataArray = new Uint8Array(analyser.frequencyBinBinCount);

                source = audioCtx.createMediaElementSource(audioEl);
                source.connect(analyser);
                analyser.connect(audioCtx.destination); 
            }
        }

        document.getElementById('audio-input').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const url = URL.createObjectURL(file);
            audioEl.src = url;
            log("AUDIO LOADED: " + file.name);
            playBtn.disabled = false;
        });

        playBtn.addEventListener('click', () => {
            setupAudioContext();
            if (audioCtx.state === 'suspended') audioCtx.resume();

            if (audioEl.paused) {
                audioEl.play();
                playBtn.innerText = "PAUSE";
                playBtn.classList.add('active');
                log("PLAYING AUDIO...");
            } else {
                audioEl.pause();
                playBtn.innerText = "PLAY";
                playBtn.classList.remove('active');
                log("AUDIO PAUSED.");
            }
        });


        // --- 4. VRM LOADER ---
        const loader = new GLTFLoader();
        loader.register((parser) => new VRMLoaderPlugin(parser));
        let currentVrm = null;

        function loadVRM(url) {
            loader.load(url, (gltf) => {
                if(currentVrm) {
                    scene.remove(currentVrm.scene);
                    VRMUtils.deepDispose(currentVrm.scene);
                }
                const vrm = gltf.userData.vrm;
                VRMUtils.rotateVRM0(vrm);
                currentVrm = vrm;
                scene.add(vrm.scene);
                
                // ポーズはデフォルトのままか、少し中性的なポーズに
                vrm.humanoid.getNormalizedBoneNode('leftUpperArm').rotation.z = 0.5;
                vrm.humanoid.getNormalizedBoneNode('rightUpperArm').rotation.z = -0.5;
                vrm.humanoid.getNormalizedBoneNode('spine').rotation.x = 0.1; // 少し胸を張る

                log("VRM LOADED: " + (gltf.userData.vrm.meta.title || "Unknown VRM"));
            }, undefined, (e) => log("VRM LOAD ERROR: " + e.message));
        }
        
        // Default VRM
        loadVRM('https://raw.githubusercontent.com/pixiv/three-vrm/master/packages/three-vrm/examples/models/VRM1_Constraint_Twist_Sample.vrm');

        document.getElementById('vrm-input').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) loadVRM(URL.createObjectURL(new Blob([file], { type: "application/octet-stream" })));
        });


        // --- 5. RECORDER (High Bitrate) ---
        let mediaRecorder;
        let recordedChunks = [];
        const recBtn = document.getElementById('btn-rec');
        const recIndicator = document.getElementById('rec-indicator');

        recBtn.addEventListener('click', () => {
            if (mediaRecorder && mediaRecorder.state === 'recording') stopRecording();
            else startRecording();
        });

        function startRecording() {
            const canvasStream = canvas.captureStream(60); 
            if (audioCtx && !audioEl.paused) {
                const dest = audioCtx.createMediaStreamDestination();
                source.connect(dest); 
                canvasStream.addTrack(dest.stream.getAudioTracks()[0]);
            }
            
            let options = { mimeType: 'video/webm;codecs=vp9', videoBitsPerSecond: 8000000, audioBitsPerSecond: 128000 }; // さらに高画質・高音質
            if (!MediaRecorder.isTypeSupported(options.mimeType)) options = { mimeType: 'video/webm' };

            mediaRecorder = new MediaRecorder(canvasStream, options);
            mediaRecorder.ondataavailable = (e) => { if (e.data.size > 0) recordedChunks.push(e.data); };
            mediaRecorder.onstop = () => {
                const blob = new Blob(recordedChunks, { type: 'video/webm' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                a.download = 'vj_destruction_' + Date.now() + '.webm';
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
                recordedChunks = [];
                log("RECORDING SAVED.");
            };

            mediaRecorder.start();
            recBtn.innerText = "STOP REC";
            recBtn.classList.add('active');
            recIndicator.style.display = 'block';
            log("RECORDING IN PROGRESS...");
        }

        function stopRecording() {
            mediaRecorder.stop();
            recBtn.innerText = "REC START";
            recBtn.classList.remove('active');
            recIndicator.style.display = 'none';
        }


        // --- 6. MAIN LOOP ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const deltaTime = clock.getDelta();
            const time = clock.getElapsedTime();

            let low = 0, mid = 0, high = 0;

            if (analyser && !audioEl.paused) {
                analyser.getByteFrequencyData(dataArray);
                
                // バンド帯域をより細かく分割 (fftSize=1024なのでbinCount=512)
                const bassData = dataArray.slice(0, 30);      // 0-30Hz付近
                const midData = dataArray.slice(30, 200);     // 30Hz-1kHz付近
                const highData = dataArray.slice(200, 500);   // 1kHz-3kHz付近
                
                const avg = (arr) => arr.length > 0 ? arr.reduce((a, b) => a + b, 0) / arr.length : 0;
                
                low = avg(bassData) / 255.0;
                mid = avg(midData) / 255.0;
                high = avg(highData) / 255.0;
            }

            // VRM Animation - アバターを中央固定、ゆっくり回転
            if (currentVrm) {
                currentVrm.update(deltaTime);
                currentVrm.scene.rotation.y += 0.005; // ゆっくり回転
                currentVrm.scene.position.set(0, 0, 0); // 中央に固定

                // 音量に合わせて微調整
                const breathScale = 1.0 + Math.sin(time * 2.0) * 0.01 + (low * 0.05); // 呼吸のような微動
                currentVrm.scene.scale.set(breathScale, breathScale, breathScale);

                // 顔の向きがランダムに切り替わる
                if (Math.random() > 0.99) {
                    currentVrm.humanoid.getNormalizedBoneNode('neck').rotation.y = (Math.random() - 0.5) * 0.5;
                }
            }

            // Shader Uniforms Update
            destructionPass.uniforms['time'].value = time;
            destructionPass.uniforms['audioLow'].value = low;
            destructionPass.uniforms['audioMid'].value = mid;
            destructionPass.uniforms['audioHigh'].value = high;
            
            // カメラは固定
            camera.position.x = 0;
            camera.position.y = 1.4;
            camera.lookAt(0, 1.0, 0);

            composer.render();
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            destructionPass.uniforms['resolution'].value.set(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>

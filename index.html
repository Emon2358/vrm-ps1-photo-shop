<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VRM to PS1 LowPoly Converter (Advanced)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #202020; color: white; font-family: monospace; }
        #ui-container {
            position: absolute; top: 10px; left: 10px; 
            background: rgba(0, 0, 0, 0.8); padding: 15px; 
            border-radius: 8px; border: 1px solid #444;
            max-width: 320px; /* Slightly wider */
            max-height: calc(100vh - 20px); /* Adjust height for scrolling */
            overflow-y: auto; /* Enable scrolling for long UI */
        }
        input[type=file] { margin-bottom: 10px; width: 100%; }
        label { display: block; margin-top: 10px; font-size: 12px; }
        input[type=range], select { width: 100%; margin-bottom: 5px; }
        button { margin-top: 10px; width: 100%; padding: 8px; cursor: pointer; background: #444; color: #fff; border: none; }
        button:hover { background: #666; }
        .note { font-size: 10px; color: #aaa; margin-top: 5px; }
        .section-separator { border-top: 1px solid #555; margin-top: 15px; padding-top: 10px; }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "@pixiv/three-vrm": "https://unpkg.com/@pixiv/three-vrm@2.1.0/lib/three-vrm.module.js"
            }
        }
    </script>
</head>
<body>

<div id="ui-container">
    <h3>VRM to PS1 Style (Advanced)</h3>
    <input type="file" id="vrm-file-input" accept=".vrm">
    
    <div class="section-separator">
        <h4>Render Settings</h4>
        <label>Render Resolution (Pixelation): <span id="res-val">0.2</span></label>
        <input type="range" id="res-slider" min="0.05" max="1.0" step="0.05" value="0.2">

        <label>Polygon Reduction Ratio: <span id="poly-val">0 (Original)</span></label>
        <input type="range" id="poly-slider" min="0" max="0.9" step="0.05" value="0">
        <div class="note">※ポリゴン削減を行うとアニメーション（ボーン）が停止します（Mesh化されるため）。</div>
        <button id="apply-btn">Apply Low Poly (Destructive)</button>
    </div>

    <div class="section-separator">
        <h4>Background</h4>
        <input type="file" id="bg-file-input" accept="image/*">
        <button id="clear-bg-btn">Clear Background</button>
    </div>

    <div class="section-separator">
        <h4>Pose & Animation</h4>
        <label>Rotation</label>
        <input type="checkbox" id="auto-rotate" checked> Auto Rotate Model
        
        <label>Left Arm Bend: <span id="left-arm-val">0</span></label>
        <input type="range" id="left-arm-slider" min="-90" max="90" step="1" value="0">
        <div class="note">※Humanoidボーンが取得できる場合のみ有効です。</div>

        </div>

    <div class="section-separator">
        <h4>Camera & Controls</h4>
        <button id="reset-camera-btn">Reset Camera View</button>
    </div>

    <div class="section-separator">
        <h4>Screenshot</h4>
        <label>Screenshot Scale: <span id="screenshot-scale-val">1</span>x</label>
        <input type="range" id="screenshot-scale-slider" min="0.5" max="3" step="0.1" value="1">
        <button id="screenshot-btn">Take Screenshot</button>
    </div>
</div>

<script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { SimplifyModifier } from 'three/addons/modifiers/SimplifyModifier.js';
    import { VRMLoaderPlugin, VRMUtils } from '@pixiv/three-vrm';

    // --- Scene Setup ---
    const renderer = new THREE.WebGLRenderer({ antialias: false, preserveDrawingBuffer: true }); // preserveDrawingBuffer for screenshot
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000); // Default black background

    const camera = new THREE.PerspectiveCamera(30, window.innerWidth / window.innerHeight, 0.1, 20.0);
    camera.position.set(0.0, 1.4, 3.0);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.target.set(0.0, 1.0, 0.0);
    controls.update();

    // Light
    const light = new THREE.DirectionalLight(0xffffff, 1.5);
    light.position.set(1.0, 1.0, 1.0).normalize();
    scene.add(light);
    const ambient = new THREE.AmbientLight(0x404040);
    scene.add(ambient);

    // --- State ---
    let currentVrm = null;
    let currentMixer = null; // For animations
    let currentAction = null;

    // --- Loader ---
    const loader = new GLTFLoader();
    loader.register((parser) => {
        return new VRMLoaderPlugin(parser);
    });

    // --- Helpers ---
    function setPS1Textures(object) {
        object.traverse((child) => {
            if (child.isMesh && child.material) {
                const mats = Array.isArray(child.material) ? child.material : [child.material];
                
                mats.forEach(mat => {
                    if (mat.map) {
                        mat.map.minFilter = THREE.NearestFilter;
                        mat.map.magFilter = THREE.NearestFilter;
                        mat.map.needsUpdate = true;
                    }
                });
            }
        });
    }

    function applyDecimation(ratio) {
        if (!currentVrm) return;
        
        const modifier = new SimplifyModifier();

        currentVrm.scene.traverse((child) => {
            if (child.isMesh) {
                if (!child.userData.originalGeometry) {
                    child.userData.originalGeometry = child.geometry.clone();
                }

                const originalGeo = child.userData.originalGeometry;
                const count = Math.floor(originalGeo.attributes.position.count * ratio);
                
                if (count > 0 && ratio > 0) {
                    try {
                        const simplifiedGeo = modifier.modify(originalGeo, count);
                        child.geometry.dispose();
                        child.geometry = simplifiedGeo;
                    } catch (e) {
                        console.warn("Simplification failed for mesh:", child.name, e);
                    }
                } else {
                    child.geometry.dispose();
                    child.geometry = originalGeo.clone();
                }
            }
        });
        // After decimation, animations are usually broken. Stop mixer.
        if (currentMixer) {
            currentMixer.stopAllAction();
            currentMixer = null;
        }
    }

    // --- Event Listeners ---
    // VRM File Input
    const vrmFileInput = document.getElementById('vrm-file-input');
    vrmFileInput.addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (!file) return;

        const blobUrl = URL.createObjectURL(file);
        
        if (currentVrm) {
            scene.remove(currentVrm.scene);
            VRMUtils.deepDispose(currentVrm.scene);
            currentVrm = null;
            if (currentMixer) {
                currentMixer.stopAllAction();
                currentMixer = null;
            }
        }

        loader.load(
            blobUrl,
            (gltf) => {
                const vrm = gltf.userData.vrm;
                VRMUtils.removeUnnecessaryVertices(gltf.scene);
                VRMUtils.removeUnnecessaryJoints(gltf.scene);

                currentVrm = vrm;
                scene.add(vrm.scene);
                
                vrm.scene.rotation.y = Math.PI;

                setPS1Textures(vrm.scene);

                // Setup animation mixer if animations exist
                if (gltf.animations.length) {
                    currentMixer = new THREE.AnimationMixer(vrm.scene);
                    // For simplicity, play the first animation if available
                    // A more advanced UI would let the user select from multiple clips
                    currentAction = currentMixer.clipAction(gltf.animations[0]);
                    // currentAction.play(); // Don't auto-play for now, let user control
                }
                
                console.log("VRM Loaded", vrm);
            },
            (progress) => console.log('Loading VRM...', 100.0 * (progress.loaded / progress.total) + '%'),
            (error) => console.error('Error loading VRM:', error)
        );
    });

    // Background File Input
    const bgFileInput = document.getElementById('bg-file-input');
    bgFileInput.addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (e) => {
            const textureLoader = new THREE.TextureLoader();
            textureLoader.load(e.target.result, (texture) => {
                // Ensure PS1 pixelation for background too
                texture.minFilter = THREE.NearestFilter;
                texture.magFilter = THREE.NearestFilter;
                scene.background = texture;
            });
        };
        reader.readAsDataURL(file);
    });

    // Clear Background Button
    document.getElementById('clear-bg-btn').addEventListener('click', () => {
        if (scene.background) {
            if (scene.background.dispose) scene.background.dispose(); // Release texture memory
            scene.background = new THREE.Color(0x000000); // Reset to black
        }
        bgFileInput.value = ''; // Clear file input display
    });

    // Render Resolution Slider
    const resSlider = document.getElementById('res-slider');
    const resVal = document.getElementById('res-val');
    resSlider.addEventListener('input', (e) => {
        const val = parseFloat(e.target.value);
        resVal.textContent = val;
        renderer.setPixelRatio(window.devicePixelRatio * val);
        renderer.domElement.style.imageRendering = 'pixelated'; 
    });

    // Poly Reduction Slider
    const polySlider = document.getElementById('poly-slider');
    const polyVal = document.getElementById('poly-val');
    polySlider.addEventListener('input', (e) => {
        polyVal.textContent = e.target.value;
    });

    // Apply Low Poly Button
    document.getElementById('apply-btn').addEventListener('click', () => {
        const ratio = parseFloat(polySlider.value);
        applyDecimation(ratio);
    });

    // Auto Rotate Checkbox
    const autoRotateCheckbox = document.getElementById('auto-rotate');

    // Left Arm Bend Slider (Simple Pose Control)
    const leftArmSlider = document.getElementById('left-arm-slider');
    const leftArmVal = document.getElementById('left-arm-val');
    leftArmSlider.addEventListener('input', (e) => {
        const angleDeg = parseFloat(e.target.value);
        leftArmVal.textContent = angleDeg;
        if (currentVrm) {
            const leftUpperArm = currentVrm.humanoid.get  `LeftUpperArm`;
            if (leftUpperArm) {
                // Rotate around X-axis for bending (local space)
                leftUpperArm.rotation.x = THREE.MathUtils.degToRad(angleDeg);
                leftUpperArm.updateMatrixWorld(true); // Ensure bone rotation is applied
            }
        }
    });

    // Reset Camera Button
    document.getElementById('reset-camera-btn').addEventListener('click', () => {
        camera.position.set(0.0, 1.4, 3.0);
        controls.target.set(0.0, 1.0, 0.0);
        controls.update();
    });

    // Screenshot Scale Slider
    const screenshotScaleSlider = document.getElementById('screenshot-scale-slider');
    const screenshotScaleVal = document.getElementById('screenshot-scale-val');
    screenshotScaleSlider.addEventListener('input', (e) => {
        screenshotScaleVal.textContent = e.target.value;
    });

    // Screenshot Button
    document.getElementById('screenshot-btn').addEventListener('click', () => {
        const scale = parseFloat(screenshotScaleSlider.value);
        const originalWidth = window.innerWidth;
        const originalHeight = window.innerHeight;

        // Temporarily resize renderer for higher resolution screenshot
        renderer.setSize(originalWidth * scale, originalHeight * scale);
        renderer.render(scene, camera); // Render again with new size

        const dataURL = renderer.domElement.toDataURL('image/png');
        const link = document.createElement('a');
        link.download = `vrm_ps1_screenshot_${Date.now()}.png`;
        link.href = dataURL;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);

        // Restore original renderer size
        renderer.setSize(originalWidth, originalHeight);
        renderer.render(scene, camera); // Render again to restore view
    });


    // --- Animation Loop ---
    const clock = new THREE.Clock();

    function animate() {
        requestAnimationFrame(animate);

        const delta = clock.getDelta();

        if (currentVrm) {
            currentVrm.update(delta);
            if (autoRotateCheckbox.checked) {
                currentVrm.scene.rotation.y += delta * 0.5;
            }
        }
        
        if (currentMixer) {
            currentMixer.update(delta);
        }

        renderer.render(scene, camera);
    }

    animate();

    // Resize handler
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        // Ensure pixel ratio is reapplied correctly on resize
        renderer.setPixelRatio(window.devicePixelRatio * parseFloat(resSlider.value));
    });

</script>
</body>
</html>
